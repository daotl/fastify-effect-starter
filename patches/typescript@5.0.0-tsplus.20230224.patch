diff --git a/lib/lib.dom.d.ts b/lib/lib.dom.d.ts
index a1bc18a..b7f73d2 100644
--- a/lib/lib.dom.d.ts
+++ b/lib/lib.dom.d.ts
@@ -17078,6 +17078,12 @@ interface Window extends EventTarget, AnimationFrameProvider, GlobalEventHandler
     addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
     removeEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
     removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
+
+    // proza: Moved Option here so that it doesnt interfeir in the global space.
+    Option: {
+        new(text?: string, value?: string, defaultSelected?: boolean, selected?: boolean): HTMLOptionElement;
+    };
+
     [index: number]: Window;
 }
 
@@ -18064,9 +18070,6 @@ declare var Audio: {
 declare var Image: {
     new(width?: number, height?: number): HTMLImageElement;
 };
-declare var Option: {
-    new(text?: string, value?: string, defaultSelected?: boolean, selected?: boolean): HTMLOptionElement;
-};
 /** @deprecated This is a legacy alias of `navigator`. */
 declare var clientInformation: Navigator;
 /** Returns true if the window has been closed, false otherwise. */
diff --git a/lib/tsc.js b/lib/tsc.js
index dcf619b..ff48cd8 100644
--- a/lib/tsc.js
+++ b/lib/tsc.js
@@ -43064,7 +43064,8 @@ function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory,
       for (const key of getOwnKeys(exports)) {
         if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
           const subTarget = exports[key];
-          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+          const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
           if (result) {
             return result;
           }
@@ -43136,7 +43137,7 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
     return void 0;
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
   const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
   return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
   function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -44137,52 +44138,52 @@ function createTypeChecker(host) {
     }
     return out;
   }
-  function collectRelevantSymbolsLoop(target, lastNoInherit, lastSeen) {
+  function collectRelevantSymbolsLoop(originalTarget, lastNoInherit, lastSeen) {
     const seen = new Set(lastSeen);
     const noInherit = new Set(lastNoInherit);
     const relevant = /* @__PURE__ */ new Set();
-    let queue = [target];
+    let queue = [originalTarget];
     while (queue.length > 0) {
-      const target2 = queue.shift();
-      if (target2.symbol) {
-        collectExcludedInheritance(target2.symbol);
-      }
-      if (target2.aliasSymbol) {
-        collectExcludedInheritance(target2.aliasSymbol);
-      }
-      if (target2.symbol && shouldInherit(target2.symbol)) {
-        relevant.add(target2.symbol);
-        if (inheritanceSymbolCache.has(target2.symbol)) {
-          inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
-        } else if (target2.symbol.declarations) {
-          target2.symbol.declarations.forEach((declaration) => {
+      const target = queue.shift();
+      if (target.symbol) {
+        collectExcludedInheritance(target.symbol);
+      }
+      if (target.aliasSymbol) {
+        collectExcludedInheritance(target.aliasSymbol);
+      }
+      if (target.symbol && shouldInherit(target.symbol)) {
+        relevant.add(target.symbol);
+        if (inheritanceSymbolCache.has(target.symbol)) {
+          inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
+        } else if (target.symbol.declarations) {
+          target.symbol.declarations.forEach((declaration) => {
             if ((isInterfaceDeclaration(declaration) || isClassDeclaration(declaration)) && declaration.heritageClauses) {
-              tryCacheTsPlusInheritance(target2.symbol, declaration.heritageClauses);
-              if (inheritanceSymbolCache.has(target2.symbol)) {
-                inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
+              tryCacheTsPlusInheritance(target.symbol, declaration.heritageClauses);
+              if (inheritanceSymbolCache.has(target.symbol)) {
+                inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
               }
             }
           });
         }
       }
-      if (target2.aliasSymbol && shouldInherit(target2.aliasSymbol)) {
-        relevant.add(target2.aliasSymbol);
-        if (inheritanceSymbolCache.has(target2.aliasSymbol)) {
-          inheritanceSymbolCache.get(target2.aliasSymbol).forEach(addInheritedSymbol);
+      if (target.aliasSymbol && shouldInherit(target.aliasSymbol)) {
+        relevant.add(target.aliasSymbol);
+        if (inheritanceSymbolCache.has(target.aliasSymbol)) {
+          inheritanceSymbolCache.get(target.aliasSymbol).forEach(addInheritedSymbol);
         }
-        if (target2.flags & 1048576 /* Union */) {
-          collectUnionType(target2);
+        if (target.flags & 1048576 /* Union */) {
+          collectUnionType(target);
         }
-        if (target2.flags & 2097152 /* Intersection */) {
-          collectIntersectionType(target2);
+        if (target.flags & 2097152 /* Intersection */) {
+          collectIntersectionType(target);
         }
       }
-      if (!target2.symbol && !target2.aliasSymbol) {
-        if (target2.flags & 1048576 /* Union */) {
-          collectUnionType(target2);
+      if (!target.symbol && !target.aliasSymbol) {
+        if (target.flags & 1048576 /* Union */) {
+          collectUnionType(target);
         }
-        if (target2.flags & 2097152 /* Intersection */) {
-          collectIntersectionType(target2);
+        if (target.flags & 2097152 /* Intersection */) {
+          collectIntersectionType(target);
         }
       }
     }
@@ -44290,15 +44291,37 @@ function createTypeChecker(host) {
     }
     return returnArray;
   }
+  function getAllTypeTags(targetType) {
+    var _a2, _b, _c;
+    return (_c = (_b = (_a2 = targetType.symbol) == null ? void 0 : _a2.declarations) == null ? void 0 : _b.flatMap(collectTsPlusTypeTags)) != null ? _c : [];
+  }
+  function isInstanceType(type) {
+    if (!type.symbol) {
+      return true;
+    }
+    if (!(type.symbol.flags & 32 /* Class */)) {
+      return true;
+    }
+    const declaredType = getDeclaredTypeOfClassOrInterface(type.symbol);
+    if (!declaredType.symbol) {
+      return true;
+    }
+    return getTypeOfSymbol(declaredType.symbol) !== type;
+  }
   function getExtensions(selfNode) {
     var _a2, _b;
     const targetType = getTypeOfNode(selfNode);
+    const isInstance = isInstanceType(targetType);
     const symbols = collectRelevantSymbols(targetType);
     const copy = /* @__PURE__ */ new Map();
     const copyFluent = /* @__PURE__ */ new Map();
+    const typeTags = getAllTypeTags(targetType);
     symbols.forEach((target) => {
-      if (typeSymbolCache.has(target) && !isCompanionReference(selfNode)) {
+      if (typeSymbolCache.has(target)) {
         typeSymbolCache.get(target).forEach((typeSymbol) => {
+          if (!isInstance && typeTags.includes(typeSymbol)) {
+            return;
+          }
           const _static = staticCache.get(typeSymbol);
           if (_static) {
             _static.forEach((v, k) => {
@@ -44407,17 +44430,22 @@ function createTypeChecker(host) {
   }
   function unionIfLazy(_paramType) {
     const isLazy = isLazyParameterByType(_paramType);
-    const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : _paramType;
+    const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : isForceLazyParameterByType(_paramType) ? _paramType.resolvedTypeArguments[0] : _paramType;
     return paramType;
   }
   function getFluentExtension(targetType, name) {
     var _a2, _b;
+    const isInstance = isInstanceType(targetType);
+    const typeTags = getAllTypeTags(targetType);
     const symbols = collectRelevantSymbols(targetType);
     const candidates = /* @__PURE__ */ new Set();
     for (const target of symbols) {
       if (typeSymbolCache.has(target)) {
         const x = typeSymbolCache.get(target).flatMap(
           (tag) => {
+            if (!isInstance && typeTags.includes(tag)) {
+              return [];
+            }
             if (fluentCache.has(tag)) {
               const cache = fluentCache.get(tag);
               if (cache == null ? void 0 : cache.has(name)) {
@@ -44454,10 +44482,15 @@ function createTypeChecker(host) {
   function getGetterExtension(targetType, name) {
     var _a2;
     const symbols = collectRelevantSymbols(targetType);
+    const isInstance = isInstanceType(targetType);
+    const typeTags = getAllTypeTags(targetType);
     for (const target of symbols) {
       if (typeSymbolCache.has(target)) {
         const x = typeSymbolCache.get(target).flatMap(
           (tag) => {
+            if (!isInstance && typeTags.includes(tag)) {
+              return [];
+            }
             if (getterCache.has(tag)) {
               const cache = getterCache.get(tag);
               if (cache == null ? void 0 : cache.has(name)) {
@@ -49047,17 +49080,17 @@ function createTypeChecker(host) {
         const typeId = type2.id;
         const symbol = type2.symbol;
         if (symbol) {
-          const isInstanceType = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
+          const isInstanceType2 = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
           if (isJSConstructor(symbol.valueDeclaration)) {
-            return symbolToTypeNode(symbol, context, isInstanceType);
+            return symbolToTypeNode(symbol, context, isInstanceType2);
           } else if (symbol.flags & 32 /* Class */ && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & 2048 /* WriteClassExpressionAsTypeLiteral */ && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(
             symbol,
             context.enclosingDeclaration,
-            isInstanceType,
+            isInstanceType2,
             /*computeAliases*/
             false
           ).accessibility !== 0 /* Accessible */)) || symbol.flags & (384 /* Enum */ | 512 /* ValueModule */) || shouldWriteTypeOfFunctionSymbol()) {
-            return symbolToTypeNode(symbol, context, isInstanceType);
+            return symbolToTypeNode(symbol, context, isInstanceType2);
           } else if ((_a3 = context.visitedTypes) == null ? void 0 : _a3.has(typeId)) {
             const typeAlias = getTypeAliasForTypeLiteral(type2);
             if (typeAlias) {
@@ -49908,6 +49941,16 @@ function createTypeChecker(host) {
       }
       return top;
     }
+    function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+      let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+      if (specifier && specifier.indexOf("/node_modules/") > 0) {
+        const r = tryGetImportLocation(fileMap.map, specifier);
+        if (r) {
+          specifier = r;
+        }
+      }
+      return specifier;
+    }
     function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
       var _a2;
       let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -49982,7 +50025,7 @@ function createTypeChecker(host) {
         let assertion;
         if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
           if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
             assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
               factory.createAssertEntry(
                 factory.createStringLiteral("resolution-mode"),
@@ -49993,7 +50036,7 @@ function createTypeChecker(host) {
           }
         }
         if (!specifier) {
-          specifier = getSpecifierForModuleSymbol(chain[0], context);
+          specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
         }
         if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
           const oldSpecifier = specifier;
@@ -65915,11 +65958,19 @@ function createTypeChecker(host) {
           if (type) {
             const name = node.name;
             const symbol2 = type.symbol || type.aliasSymbol;
-            if (symbol2 && typeSymbolCache.has(symbol2)) {
+            if (symbol2 && (typeSymbolCache.has(symbol2) || companionSymbolCache.has(symbol2))) {
               const fluentExtenion = getFluentExtension(type, name.escapedText);
               if (fluentExtenion) {
                 return fluentExtenion;
               }
+              const staticExtension = getStaticExtension(type, name.escapedText);
+              if (staticExtension) {
+                return staticExtension.type;
+              }
+              const staticCompanionExtension = getStaticCompanionExtension(type, name.escapedText);
+              if (staticCompanionExtension) {
+                return staticCompanionExtension.type;
+              }
             }
             let prop;
             if (isPrivateIdentifier(name)) {
@@ -70131,7 +70182,6 @@ function createTypeChecker(host) {
           nodeLinks2.tsPlusResolvedType = companionExt.type;
           return companionExt.type;
         }
-        return;
       }
       const fluentExtType = getFluentExtension(leftType, right.escapedText.toString());
       if (fluentExtType && isCallExpression(node.parent) && node.parent.expression === node) {
@@ -71028,6 +71078,15 @@ function createTypeChecker(host) {
     }
     return false;
   }
+  function isForceLazyParameterByType(type) {
+    if (type.symbol && type.symbol.declarations && type.symbol.declarations.length > 0) {
+      const tag = collectTsPlusTypeTags(type.symbol.declarations[0])[0];
+      if (tag === "tsplus/ForceLazyArgument") {
+        return true;
+      }
+    }
+    return false;
+  }
   function getMutableArrayOrTupleType(type) {
     return type.flags & 1048576 /* Union */ ? mapType(type, getMutableArrayOrTupleType) : type.flags & 1 /* Any */ || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type : isTupleType(type) ? createTupleType(
       getTypeArguments(type),
@@ -71233,7 +71292,7 @@ function createTypeChecker(host) {
       const thisArgumentType = getThisArgumentType(thisArgumentNode);
       const originalParamType = thisType;
       let paramType = originalParamType;
-      if (isLazyParameterByType(originalParamType) && thisArgumentNode) {
+      if ((isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) && thisArgumentNode) {
         const contextFreeArgType = thisArgumentType;
         if (isTypeIdenticalTo(contextFreeArgType, anyType) || isTypeIdenticalTo(contextFreeArgType, neverType)) {
           return [createDiagnosticForNode(
@@ -71271,7 +71330,7 @@ function createTypeChecker(host) {
           checkMode
         );
         let paramType = originalParamType;
-        if (isLazyParameterByType(originalParamType)) {
+        if (isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) {
           if ((isTypeIdenticalTo(argType, anyType) || isTypeIdenticalTo(argType, neverType)) && !(checkMode & 8 /* SkipGenericFunctions */)) {
             return [createDiagnosticForNode(
               arg,
@@ -84682,7 +84741,46 @@ function createTypeChecker(host) {
     const heritageExtensions = inheritanceSymbolCache.get(typeSymbol);
     forEach(heritage, (clause) => {
       forEach(clause.types, (node) => {
+        var _a2;
         const type = getTypeOfNode(node);
+        if (isIdentifier(node.expression)) {
+          const links = getNodeLinks(node.expression);
+          const declaration = (_a2 = links.resolvedSymbol) == null ? void 0 : _a2.valueDeclaration;
+          const vType = declaration && checker.getTypeAtLocation(declaration);
+          if (vType) {
+            if (vType.symbol) {
+              heritageExtensions.add(vType.symbol);
+            }
+            if (vType.flags & 2097152 /* Intersection */) {
+              forEach(vType.types, (type2) => {
+                if (type2.symbol) {
+                  heritageExtensions.add(type2.symbol);
+                }
+                if (type2.aliasSymbol) {
+                  heritageExtensions.add(type2.aliasSymbol);
+                }
+              });
+            }
+          }
+        } else if (isCallExpression(node.expression)) {
+          const resolvedSignature = getResolvedSignature(node.expression);
+          const returnType = resolvedSignature.resolvedReturnType;
+          if (returnType) {
+            if (returnType.symbol) {
+              heritageExtensions.add(returnType.symbol);
+            }
+            if (returnType.flags & 2097152 /* Intersection */) {
+              forEach(returnType.types, (type2) => {
+                if (type2.symbol) {
+                  heritageExtensions.add(type2.symbol);
+                }
+                if (type2.aliasSymbol) {
+                  heritageExtensions.add(type2.aliasSymbol);
+                }
+              });
+            }
+          }
+        }
         if (type.symbol) {
           heritageExtensions.add(type.symbol);
         }
@@ -89247,13 +89345,27 @@ function getOriginalNodeId(node) {
   node = getOriginalNode(node);
   return node ? getNodeId(node) : 0;
 }
-function getImportLocation(fileMap, source) {
+var importLocationCache = {};
+function tryGetImportLocation(fileMap, source) {
+  if (source in importLocationCache) {
+    return importLocationCache[source];
+  }
   for (const [path, reg] of fileMap) {
     if (source.match(reg)) {
-      return source.replace(reg, path);
+      const r = source.replace(reg, path);
+      importLocationCache[source] = r;
+      return r;
     }
   }
-  throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  importLocationCache[source] = void 0;
+  return void 0;
+}
+function getImportLocation(fileMap, source) {
+  const found = tryGetImportLocation(fileMap, source);
+  if (!found) {
+    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  }
+  return found;
 }
 function getTraceLocation(traceMap, source) {
   for (const [path, reg] of traceMap) {
diff --git a/lib/tsserver.js b/lib/tsserver.js
index 574ebb6..4b86a29 100644
--- a/lib/tsserver.js
+++ b/lib/tsserver.js
@@ -2225,6 +2225,7 @@ __export(server_exports, {
   tryGetDirectories: () => tryGetDirectories,
   tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
   tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+  tryGetImportLocation: () => tryGetImportLocation,
   tryGetJSDocSatisfiesTypeNode: () => tryGetJSDocSatisfiesTypeNode,
   tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
@@ -47188,7 +47189,8 @@ function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory,
       for (const key of getOwnKeys(exports)) {
         if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
           const subTarget = exports[key];
-          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+          const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
           if (result) {
             return result;
           }
@@ -47260,7 +47262,7 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
     return void 0;
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
   const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
   return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
   function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -48261,52 +48263,52 @@ function createTypeChecker(host) {
     }
     return out;
   }
-  function collectRelevantSymbolsLoop(target, lastNoInherit, lastSeen) {
+  function collectRelevantSymbolsLoop(originalTarget, lastNoInherit, lastSeen) {
     const seen = new Set(lastSeen);
     const noInherit = new Set(lastNoInherit);
     const relevant = /* @__PURE__ */ new Set();
-    let queue = [target];
+    let queue = [originalTarget];
     while (queue.length > 0) {
-      const target2 = queue.shift();
-      if (target2.symbol) {
-        collectExcludedInheritance(target2.symbol);
-      }
-      if (target2.aliasSymbol) {
-        collectExcludedInheritance(target2.aliasSymbol);
-      }
-      if (target2.symbol && shouldInherit(target2.symbol)) {
-        relevant.add(target2.symbol);
-        if (inheritanceSymbolCache.has(target2.symbol)) {
-          inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
-        } else if (target2.symbol.declarations) {
-          target2.symbol.declarations.forEach((declaration) => {
+      const target = queue.shift();
+      if (target.symbol) {
+        collectExcludedInheritance(target.symbol);
+      }
+      if (target.aliasSymbol) {
+        collectExcludedInheritance(target.aliasSymbol);
+      }
+      if (target.symbol && shouldInherit(target.symbol)) {
+        relevant.add(target.symbol);
+        if (inheritanceSymbolCache.has(target.symbol)) {
+          inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
+        } else if (target.symbol.declarations) {
+          target.symbol.declarations.forEach((declaration) => {
             if ((isInterfaceDeclaration(declaration) || isClassDeclaration(declaration)) && declaration.heritageClauses) {
-              tryCacheTsPlusInheritance(target2.symbol, declaration.heritageClauses);
-              if (inheritanceSymbolCache.has(target2.symbol)) {
-                inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
+              tryCacheTsPlusInheritance(target.symbol, declaration.heritageClauses);
+              if (inheritanceSymbolCache.has(target.symbol)) {
+                inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
               }
             }
           });
         }
       }
-      if (target2.aliasSymbol && shouldInherit(target2.aliasSymbol)) {
-        relevant.add(target2.aliasSymbol);
-        if (inheritanceSymbolCache.has(target2.aliasSymbol)) {
-          inheritanceSymbolCache.get(target2.aliasSymbol).forEach(addInheritedSymbol);
+      if (target.aliasSymbol && shouldInherit(target.aliasSymbol)) {
+        relevant.add(target.aliasSymbol);
+        if (inheritanceSymbolCache.has(target.aliasSymbol)) {
+          inheritanceSymbolCache.get(target.aliasSymbol).forEach(addInheritedSymbol);
         }
-        if (target2.flags & 1048576 /* Union */) {
-          collectUnionType(target2);
+        if (target.flags & 1048576 /* Union */) {
+          collectUnionType(target);
         }
-        if (target2.flags & 2097152 /* Intersection */) {
-          collectIntersectionType(target2);
+        if (target.flags & 2097152 /* Intersection */) {
+          collectIntersectionType(target);
         }
       }
-      if (!target2.symbol && !target2.aliasSymbol) {
-        if (target2.flags & 1048576 /* Union */) {
-          collectUnionType(target2);
+      if (!target.symbol && !target.aliasSymbol) {
+        if (target.flags & 1048576 /* Union */) {
+          collectUnionType(target);
         }
-        if (target2.flags & 2097152 /* Intersection */) {
-          collectIntersectionType(target2);
+        if (target.flags & 2097152 /* Intersection */) {
+          collectIntersectionType(target);
         }
       }
     }
@@ -48414,15 +48416,37 @@ function createTypeChecker(host) {
     }
     return returnArray;
   }
+  function getAllTypeTags(targetType) {
+    var _a2, _b, _c;
+    return (_c = (_b = (_a2 = targetType.symbol) == null ? void 0 : _a2.declarations) == null ? void 0 : _b.flatMap(collectTsPlusTypeTags)) != null ? _c : [];
+  }
+  function isInstanceType(type) {
+    if (!type.symbol) {
+      return true;
+    }
+    if (!(type.symbol.flags & 32 /* Class */)) {
+      return true;
+    }
+    const declaredType = getDeclaredTypeOfClassOrInterface(type.symbol);
+    if (!declaredType.symbol) {
+      return true;
+    }
+    return getTypeOfSymbol(declaredType.symbol) !== type;
+  }
   function getExtensions(selfNode) {
     var _a2, _b;
     const targetType = getTypeOfNode(selfNode);
+    const isInstance = isInstanceType(targetType);
     const symbols = collectRelevantSymbols(targetType);
     const copy = /* @__PURE__ */ new Map();
     const copyFluent = /* @__PURE__ */ new Map();
+    const typeTags = getAllTypeTags(targetType);
     symbols.forEach((target) => {
-      if (typeSymbolCache.has(target) && !isCompanionReference(selfNode)) {
+      if (typeSymbolCache.has(target)) {
         typeSymbolCache.get(target).forEach((typeSymbol) => {
+          if (!isInstance && typeTags.includes(typeSymbol)) {
+            return;
+          }
           const _static = staticCache.get(typeSymbol);
           if (_static) {
             _static.forEach((v, k) => {
@@ -48531,17 +48555,22 @@ function createTypeChecker(host) {
   }
   function unionIfLazy(_paramType) {
     const isLazy = isLazyParameterByType(_paramType);
-    const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : _paramType;
+    const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : isForceLazyParameterByType(_paramType) ? _paramType.resolvedTypeArguments[0] : _paramType;
     return paramType;
   }
   function getFluentExtension(targetType, name) {
     var _a2, _b;
+    const isInstance = isInstanceType(targetType);
+    const typeTags = getAllTypeTags(targetType);
     const symbols = collectRelevantSymbols(targetType);
     const candidates = /* @__PURE__ */ new Set();
     for (const target of symbols) {
       if (typeSymbolCache.has(target)) {
         const x = typeSymbolCache.get(target).flatMap(
           (tag) => {
+            if (!isInstance && typeTags.includes(tag)) {
+              return [];
+            }
             if (fluentCache.has(tag)) {
               const cache = fluentCache.get(tag);
               if (cache == null ? void 0 : cache.has(name)) {
@@ -48578,10 +48607,15 @@ function createTypeChecker(host) {
   function getGetterExtension(targetType, name) {
     var _a2;
     const symbols = collectRelevantSymbols(targetType);
+    const isInstance = isInstanceType(targetType);
+    const typeTags = getAllTypeTags(targetType);
     for (const target of symbols) {
       if (typeSymbolCache.has(target)) {
         const x = typeSymbolCache.get(target).flatMap(
           (tag) => {
+            if (!isInstance && typeTags.includes(tag)) {
+              return [];
+            }
             if (getterCache.has(tag)) {
               const cache = getterCache.get(tag);
               if (cache == null ? void 0 : cache.has(name)) {
@@ -53171,17 +53205,17 @@ function createTypeChecker(host) {
         const typeId = type2.id;
         const symbol = type2.symbol;
         if (symbol) {
-          const isInstanceType = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
+          const isInstanceType2 = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
           if (isJSConstructor(symbol.valueDeclaration)) {
-            return symbolToTypeNode(symbol, context, isInstanceType);
+            return symbolToTypeNode(symbol, context, isInstanceType2);
           } else if (symbol.flags & 32 /* Class */ && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & 2048 /* WriteClassExpressionAsTypeLiteral */ && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(
             symbol,
             context.enclosingDeclaration,
-            isInstanceType,
+            isInstanceType2,
             /*computeAliases*/
             false
           ).accessibility !== 0 /* Accessible */)) || symbol.flags & (384 /* Enum */ | 512 /* ValueModule */) || shouldWriteTypeOfFunctionSymbol()) {
-            return symbolToTypeNode(symbol, context, isInstanceType);
+            return symbolToTypeNode(symbol, context, isInstanceType2);
           } else if ((_a3 = context.visitedTypes) == null ? void 0 : _a3.has(typeId)) {
             const typeAlias = getTypeAliasForTypeLiteral(type2);
             if (typeAlias) {
@@ -54032,6 +54066,16 @@ function createTypeChecker(host) {
       }
       return top;
     }
+    function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+      let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+      if (specifier && specifier.indexOf("/node_modules/") > 0) {
+        const r = tryGetImportLocation(fileMap.map, specifier);
+        if (r) {
+          specifier = r;
+        }
+      }
+      return specifier;
+    }
     function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
       var _a2;
       let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -54106,7 +54150,7 @@ function createTypeChecker(host) {
         let assertion;
         if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
           if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
             assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
               factory.createAssertEntry(
                 factory.createStringLiteral("resolution-mode"),
@@ -54117,7 +54161,7 @@ function createTypeChecker(host) {
           }
         }
         if (!specifier) {
-          specifier = getSpecifierForModuleSymbol(chain[0], context);
+          specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
         }
         if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
           const oldSpecifier = specifier;
@@ -70039,11 +70083,19 @@ function createTypeChecker(host) {
           if (type) {
             const name = node.name;
             const symbol2 = type.symbol || type.aliasSymbol;
-            if (symbol2 && typeSymbolCache.has(symbol2)) {
+            if (symbol2 && (typeSymbolCache.has(symbol2) || companionSymbolCache.has(symbol2))) {
               const fluentExtenion = getFluentExtension(type, name.escapedText);
               if (fluentExtenion) {
                 return fluentExtenion;
               }
+              const staticExtension = getStaticExtension(type, name.escapedText);
+              if (staticExtension) {
+                return staticExtension.type;
+              }
+              const staticCompanionExtension = getStaticCompanionExtension(type, name.escapedText);
+              if (staticCompanionExtension) {
+                return staticCompanionExtension.type;
+              }
             }
             let prop;
             if (isPrivateIdentifier(name)) {
@@ -74255,7 +74307,6 @@ function createTypeChecker(host) {
           nodeLinks2.tsPlusResolvedType = companionExt.type;
           return companionExt.type;
         }
-        return;
       }
       const fluentExtType = getFluentExtension(leftType, right.escapedText.toString());
       if (fluentExtType && isCallExpression(node.parent) && node.parent.expression === node) {
@@ -75152,6 +75203,15 @@ function createTypeChecker(host) {
     }
     return false;
   }
+  function isForceLazyParameterByType(type) {
+    if (type.symbol && type.symbol.declarations && type.symbol.declarations.length > 0) {
+      const tag = collectTsPlusTypeTags(type.symbol.declarations[0])[0];
+      if (tag === "tsplus/ForceLazyArgument") {
+        return true;
+      }
+    }
+    return false;
+  }
   function getMutableArrayOrTupleType(type) {
     return type.flags & 1048576 /* Union */ ? mapType(type, getMutableArrayOrTupleType) : type.flags & 1 /* Any */ || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type : isTupleType(type) ? createTupleType(
       getTypeArguments(type),
@@ -75357,7 +75417,7 @@ function createTypeChecker(host) {
       const thisArgumentType = getThisArgumentType(thisArgumentNode);
       const originalParamType = thisType;
       let paramType = originalParamType;
-      if (isLazyParameterByType(originalParamType) && thisArgumentNode) {
+      if ((isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) && thisArgumentNode) {
         const contextFreeArgType = thisArgumentType;
         if (isTypeIdenticalTo(contextFreeArgType, anyType) || isTypeIdenticalTo(contextFreeArgType, neverType)) {
           return [createDiagnosticForNode(
@@ -75395,7 +75455,7 @@ function createTypeChecker(host) {
           checkMode
         );
         let paramType = originalParamType;
-        if (isLazyParameterByType(originalParamType)) {
+        if (isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) {
           if ((isTypeIdenticalTo(argType, anyType) || isTypeIdenticalTo(argType, neverType)) && !(checkMode & 8 /* SkipGenericFunctions */)) {
             return [createDiagnosticForNode(
               arg,
@@ -88806,7 +88866,46 @@ function createTypeChecker(host) {
     const heritageExtensions = inheritanceSymbolCache.get(typeSymbol);
     forEach(heritage, (clause) => {
       forEach(clause.types, (node) => {
+        var _a2;
         const type = getTypeOfNode(node);
+        if (isIdentifier(node.expression)) {
+          const links = getNodeLinks(node.expression);
+          const declaration = (_a2 = links.resolvedSymbol) == null ? void 0 : _a2.valueDeclaration;
+          const vType = declaration && checker.getTypeAtLocation(declaration);
+          if (vType) {
+            if (vType.symbol) {
+              heritageExtensions.add(vType.symbol);
+            }
+            if (vType.flags & 2097152 /* Intersection */) {
+              forEach(vType.types, (type2) => {
+                if (type2.symbol) {
+                  heritageExtensions.add(type2.symbol);
+                }
+                if (type2.aliasSymbol) {
+                  heritageExtensions.add(type2.aliasSymbol);
+                }
+              });
+            }
+          }
+        } else if (isCallExpression(node.expression)) {
+          const resolvedSignature = getResolvedSignature(node.expression);
+          const returnType = resolvedSignature.resolvedReturnType;
+          if (returnType) {
+            if (returnType.symbol) {
+              heritageExtensions.add(returnType.symbol);
+            }
+            if (returnType.flags & 2097152 /* Intersection */) {
+              forEach(returnType.types, (type2) => {
+                if (type2.symbol) {
+                  heritageExtensions.add(type2.symbol);
+                }
+                if (type2.aliasSymbol) {
+                  heritageExtensions.add(type2.aliasSymbol);
+                }
+              });
+            }
+          }
+        }
         if (type.symbol) {
           heritageExtensions.add(type.symbol);
         }
@@ -93597,13 +93696,27 @@ function getOriginalNodeId(node) {
   node = getOriginalNode(node);
   return node ? getNodeId(node) : 0;
 }
-function getImportLocation(fileMap, source) {
+var importLocationCache = {};
+function tryGetImportLocation(fileMap, source) {
+  if (source in importLocationCache) {
+    return importLocationCache[source];
+  }
   for (const [path, reg] of fileMap) {
     if (source.match(reg)) {
-      return source.replace(reg, path);
+      const r = source.replace(reg, path);
+      importLocationCache[source] = r;
+      return r;
     }
   }
-  throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  importLocationCache[source] = void 0;
+  return void 0;
+}
+function getImportLocation(fileMap, source) {
+  const found = tryGetImportLocation(fileMap, source);
+  if (!found) {
+    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  }
+  return found;
 }
 function getTraceLocation(traceMap, source) {
   for (const [path, reg] of traceMap) {
@@ -135621,6 +135734,7 @@ __export(ts_exports3, {
   tryGetDirectories: () => tryGetDirectories,
   tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
   tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+  tryGetImportLocation: () => tryGetImportLocation,
   tryGetJSDocSatisfiesTypeNode: () => tryGetJSDocSatisfiesTypeNode,
   tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
@@ -190327,6 +190441,7 @@ start(initializeNodeSystem(), require("os").platform());
   tryGetDirectories,
   tryGetExtensionFromPath,
   tryGetImportFromModuleSpecifier,
+  tryGetImportLocation,
   tryGetJSDocSatisfiesTypeNode,
   tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration,
diff --git a/lib/tsserverlibrary.d.ts b/lib/tsserverlibrary.d.ts
index 0355521..48c8e28 100644
--- a/lib/tsserverlibrary.d.ts
+++ b/lib/tsserverlibrary.d.ts
@@ -9839,6 +9839,10 @@ declare namespace ts {
      * @param context A lexical environment context for the visitor.
      */
     function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    function tryGetImportLocation(fileMap: [
+        string,
+        RegExp
+    ][], source: string): string | undefined;
     function getImportLocation(fileMap: [
         string,
         RegExp
diff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js
index 6db4923..21a2642 100644
--- a/lib/tsserverlibrary.js
+++ b/lib/tsserverlibrary.js
@@ -44995,7 +44995,8 @@ ${lanes.join("\n")}
         for (const key of getOwnKeys(exports)) {
           if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
             const subTarget = exports[key];
-            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+            const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
             if (result) {
               return result;
             }
@@ -45067,7 +45068,7 @@ ${lanes.join("\n")}
     if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
       return void 0;
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
     const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
     return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
     function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -45945,52 +45946,52 @@ ${lanes.join("\n")}
       }
       return out;
     }
-    function collectRelevantSymbolsLoop(target, lastNoInherit, lastSeen) {
+    function collectRelevantSymbolsLoop(originalTarget, lastNoInherit, lastSeen) {
       const seen = new Set(lastSeen);
       const noInherit = new Set(lastNoInherit);
       const relevant = /* @__PURE__ */ new Set();
-      let queue = [target];
+      let queue = [originalTarget];
       while (queue.length > 0) {
-        const target2 = queue.shift();
-        if (target2.symbol) {
-          collectExcludedInheritance(target2.symbol);
-        }
-        if (target2.aliasSymbol) {
-          collectExcludedInheritance(target2.aliasSymbol);
-        }
-        if (target2.symbol && shouldInherit(target2.symbol)) {
-          relevant.add(target2.symbol);
-          if (inheritanceSymbolCache.has(target2.symbol)) {
-            inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
-          } else if (target2.symbol.declarations) {
-            target2.symbol.declarations.forEach((declaration) => {
+        const target = queue.shift();
+        if (target.symbol) {
+          collectExcludedInheritance(target.symbol);
+        }
+        if (target.aliasSymbol) {
+          collectExcludedInheritance(target.aliasSymbol);
+        }
+        if (target.symbol && shouldInherit(target.symbol)) {
+          relevant.add(target.symbol);
+          if (inheritanceSymbolCache.has(target.symbol)) {
+            inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
+          } else if (target.symbol.declarations) {
+            target.symbol.declarations.forEach((declaration) => {
               if ((isInterfaceDeclaration(declaration) || isClassDeclaration(declaration)) && declaration.heritageClauses) {
-                tryCacheTsPlusInheritance(target2.symbol, declaration.heritageClauses);
-                if (inheritanceSymbolCache.has(target2.symbol)) {
-                  inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
+                tryCacheTsPlusInheritance(target.symbol, declaration.heritageClauses);
+                if (inheritanceSymbolCache.has(target.symbol)) {
+                  inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
                 }
               }
             });
           }
         }
-        if (target2.aliasSymbol && shouldInherit(target2.aliasSymbol)) {
-          relevant.add(target2.aliasSymbol);
-          if (inheritanceSymbolCache.has(target2.aliasSymbol)) {
-            inheritanceSymbolCache.get(target2.aliasSymbol).forEach(addInheritedSymbol);
+        if (target.aliasSymbol && shouldInherit(target.aliasSymbol)) {
+          relevant.add(target.aliasSymbol);
+          if (inheritanceSymbolCache.has(target.aliasSymbol)) {
+            inheritanceSymbolCache.get(target.aliasSymbol).forEach(addInheritedSymbol);
           }
-          if (target2.flags & 1048576 /* Union */) {
-            collectUnionType(target2);
+          if (target.flags & 1048576 /* Union */) {
+            collectUnionType(target);
           }
-          if (target2.flags & 2097152 /* Intersection */) {
-            collectIntersectionType(target2);
+          if (target.flags & 2097152 /* Intersection */) {
+            collectIntersectionType(target);
           }
         }
-        if (!target2.symbol && !target2.aliasSymbol) {
-          if (target2.flags & 1048576 /* Union */) {
-            collectUnionType(target2);
+        if (!target.symbol && !target.aliasSymbol) {
+          if (target.flags & 1048576 /* Union */) {
+            collectUnionType(target);
           }
-          if (target2.flags & 2097152 /* Intersection */) {
-            collectIntersectionType(target2);
+          if (target.flags & 2097152 /* Intersection */) {
+            collectIntersectionType(target);
           }
         }
       }
@@ -46098,15 +46099,37 @@ ${lanes.join("\n")}
       }
       return returnArray;
     }
+    function getAllTypeTags(targetType) {
+      var _a2, _b, _c;
+      return (_c = (_b = (_a2 = targetType.symbol) == null ? void 0 : _a2.declarations) == null ? void 0 : _b.flatMap(collectTsPlusTypeTags)) != null ? _c : [];
+    }
+    function isInstanceType(type) {
+      if (!type.symbol) {
+        return true;
+      }
+      if (!(type.symbol.flags & 32 /* Class */)) {
+        return true;
+      }
+      const declaredType = getDeclaredTypeOfClassOrInterface(type.symbol);
+      if (!declaredType.symbol) {
+        return true;
+      }
+      return getTypeOfSymbol(declaredType.symbol) !== type;
+    }
     function getExtensions(selfNode) {
       var _a2, _b;
       const targetType = getTypeOfNode(selfNode);
+      const isInstance = isInstanceType(targetType);
       const symbols = collectRelevantSymbols(targetType);
       const copy = /* @__PURE__ */ new Map();
       const copyFluent = /* @__PURE__ */ new Map();
+      const typeTags = getAllTypeTags(targetType);
       symbols.forEach((target) => {
-        if (typeSymbolCache.has(target) && !isCompanionReference(selfNode)) {
+        if (typeSymbolCache.has(target)) {
           typeSymbolCache.get(target).forEach((typeSymbol) => {
+            if (!isInstance && typeTags.includes(typeSymbol)) {
+              return;
+            }
             const _static = staticCache.get(typeSymbol);
             if (_static) {
               _static.forEach((v, k) => {
@@ -46215,17 +46238,22 @@ ${lanes.join("\n")}
     }
     function unionIfLazy(_paramType) {
       const isLazy = isLazyParameterByType(_paramType);
-      const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : _paramType;
+      const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : isForceLazyParameterByType(_paramType) ? _paramType.resolvedTypeArguments[0] : _paramType;
       return paramType;
     }
     function getFluentExtension(targetType, name) {
       var _a2, _b;
+      const isInstance = isInstanceType(targetType);
+      const typeTags = getAllTypeTags(targetType);
       const symbols = collectRelevantSymbols(targetType);
       const candidates = /* @__PURE__ */ new Set();
       for (const target of symbols) {
         if (typeSymbolCache.has(target)) {
           const x = typeSymbolCache.get(target).flatMap(
             (tag) => {
+              if (!isInstance && typeTags.includes(tag)) {
+                return [];
+              }
               if (fluentCache.has(tag)) {
                 const cache = fluentCache.get(tag);
                 if (cache == null ? void 0 : cache.has(name)) {
@@ -46262,10 +46290,15 @@ ${lanes.join("\n")}
     function getGetterExtension(targetType, name) {
       var _a2;
       const symbols = collectRelevantSymbols(targetType);
+      const isInstance = isInstanceType(targetType);
+      const typeTags = getAllTypeTags(targetType);
       for (const target of symbols) {
         if (typeSymbolCache.has(target)) {
           const x = typeSymbolCache.get(target).flatMap(
             (tag) => {
+              if (!isInstance && typeTags.includes(tag)) {
+                return [];
+              }
               if (getterCache.has(tag)) {
                 const cache = getterCache.get(tag);
                 if (cache == null ? void 0 : cache.has(name)) {
@@ -50855,17 +50888,17 @@ ${lanes.join("\n")}
           const typeId = type2.id;
           const symbol = type2.symbol;
           if (symbol) {
-            const isInstanceType = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
+            const isInstanceType2 = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
             if (isJSConstructor(symbol.valueDeclaration)) {
-              return symbolToTypeNode(symbol, context, isInstanceType);
+              return symbolToTypeNode(symbol, context, isInstanceType2);
             } else if (symbol.flags & 32 /* Class */ && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & 2048 /* WriteClassExpressionAsTypeLiteral */ && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(
               symbol,
               context.enclosingDeclaration,
-              isInstanceType,
+              isInstanceType2,
               /*computeAliases*/
               false
             ).accessibility !== 0 /* Accessible */)) || symbol.flags & (384 /* Enum */ | 512 /* ValueModule */) || shouldWriteTypeOfFunctionSymbol()) {
-              return symbolToTypeNode(symbol, context, isInstanceType);
+              return symbolToTypeNode(symbol, context, isInstanceType2);
             } else if ((_a3 = context.visitedTypes) == null ? void 0 : _a3.has(typeId)) {
               const typeAlias = getTypeAliasForTypeLiteral(type2);
               if (typeAlias) {
@@ -51716,6 +51749,16 @@ ${lanes.join("\n")}
         }
         return top;
       }
+      function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+        let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+        if (specifier && specifier.indexOf("/node_modules/") > 0) {
+          const r = tryGetImportLocation(fileMap.map, specifier);
+          if (r) {
+            specifier = r;
+          }
+        }
+        return specifier;
+      }
       function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
         var _a2;
         let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -51790,7 +51833,7 @@ ${lanes.join("\n")}
           let assertion;
           if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
             if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-              specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+              specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
               assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
                 factory.createAssertEntry(
                   factory.createStringLiteral("resolution-mode"),
@@ -51801,7 +51844,7 @@ ${lanes.join("\n")}
             }
           }
           if (!specifier) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
           }
           if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
             const oldSpecifier = specifier;
@@ -67723,11 +67766,19 @@ ${lanes.join("\n")}
             if (type) {
               const name = node.name;
               const symbol2 = type.symbol || type.aliasSymbol;
-              if (symbol2 && typeSymbolCache.has(symbol2)) {
+              if (symbol2 && (typeSymbolCache.has(symbol2) || companionSymbolCache.has(symbol2))) {
                 const fluentExtenion = getFluentExtension(type, name.escapedText);
                 if (fluentExtenion) {
                   return fluentExtenion;
                 }
+                const staticExtension = getStaticExtension(type, name.escapedText);
+                if (staticExtension) {
+                  return staticExtension.type;
+                }
+                const staticCompanionExtension = getStaticCompanionExtension(type, name.escapedText);
+                if (staticCompanionExtension) {
+                  return staticCompanionExtension.type;
+                }
               }
               let prop;
               if (isPrivateIdentifier(name)) {
@@ -71939,7 +71990,6 @@ ${lanes.join("\n")}
             nodeLinks2.tsPlusResolvedType = companionExt.type;
             return companionExt.type;
           }
-          return;
         }
         const fluentExtType = getFluentExtension(leftType, right.escapedText.toString());
         if (fluentExtType && isCallExpression(node.parent) && node.parent.expression === node) {
@@ -72836,6 +72886,15 @@ ${lanes.join("\n")}
       }
       return false;
     }
+    function isForceLazyParameterByType(type) {
+      if (type.symbol && type.symbol.declarations && type.symbol.declarations.length > 0) {
+        const tag = collectTsPlusTypeTags(type.symbol.declarations[0])[0];
+        if (tag === "tsplus/ForceLazyArgument") {
+          return true;
+        }
+      }
+      return false;
+    }
     function getMutableArrayOrTupleType(type) {
       return type.flags & 1048576 /* Union */ ? mapType(type, getMutableArrayOrTupleType) : type.flags & 1 /* Any */ || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type : isTupleType(type) ? createTupleType(
         getTypeArguments(type),
@@ -73041,7 +73100,7 @@ ${lanes.join("\n")}
         const thisArgumentType = getThisArgumentType(thisArgumentNode);
         const originalParamType = thisType;
         let paramType = originalParamType;
-        if (isLazyParameterByType(originalParamType) && thisArgumentNode) {
+        if ((isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) && thisArgumentNode) {
           const contextFreeArgType = thisArgumentType;
           if (isTypeIdenticalTo(contextFreeArgType, anyType) || isTypeIdenticalTo(contextFreeArgType, neverType)) {
             return [createDiagnosticForNode(
@@ -73079,7 +73138,7 @@ ${lanes.join("\n")}
             checkMode
           );
           let paramType = originalParamType;
-          if (isLazyParameterByType(originalParamType)) {
+          if (isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) {
             if ((isTypeIdenticalTo(argType, anyType) || isTypeIdenticalTo(argType, neverType)) && !(checkMode & 8 /* SkipGenericFunctions */)) {
               return [createDiagnosticForNode(
                 arg,
@@ -86490,7 +86549,46 @@ ${lanes.join("\n")}
       const heritageExtensions = inheritanceSymbolCache.get(typeSymbol);
       forEach(heritage, (clause) => {
         forEach(clause.types, (node) => {
+          var _a2;
           const type = getTypeOfNode(node);
+          if (isIdentifier(node.expression)) {
+            const links = getNodeLinks(node.expression);
+            const declaration = (_a2 = links.resolvedSymbol) == null ? void 0 : _a2.valueDeclaration;
+            const vType = declaration && checker.getTypeAtLocation(declaration);
+            if (vType) {
+              if (vType.symbol) {
+                heritageExtensions.add(vType.symbol);
+              }
+              if (vType.flags & 2097152 /* Intersection */) {
+                forEach(vType.types, (type2) => {
+                  if (type2.symbol) {
+                    heritageExtensions.add(type2.symbol);
+                  }
+                  if (type2.aliasSymbol) {
+                    heritageExtensions.add(type2.aliasSymbol);
+                  }
+                });
+              }
+            }
+          } else if (isCallExpression(node.expression)) {
+            const resolvedSignature = getResolvedSignature(node.expression);
+            const returnType = resolvedSignature.resolvedReturnType;
+            if (returnType) {
+              if (returnType.symbol) {
+                heritageExtensions.add(returnType.symbol);
+              }
+              if (returnType.flags & 2097152 /* Intersection */) {
+                forEach(returnType.types, (type2) => {
+                  if (type2.symbol) {
+                    heritageExtensions.add(type2.symbol);
+                  }
+                  if (type2.aliasSymbol) {
+                    heritageExtensions.add(type2.aliasSymbol);
+                  }
+                });
+              }
+            }
+          }
           if (type.symbol) {
             heritageExtensions.add(type.symbol);
           }
@@ -91455,13 +91553,26 @@ ${lanes.join("\n")}
     node = getOriginalNode(node);
     return node ? getNodeId(node) : 0;
   }
-  function getImportLocation(fileMap, source) {
+  function tryGetImportLocation(fileMap, source) {
+    if (source in importLocationCache) {
+      return importLocationCache[source];
+    }
     for (const [path, reg] of fileMap) {
       if (source.match(reg)) {
-        return source.replace(reg, path);
+        const r = source.replace(reg, path);
+        importLocationCache[source] = r;
+        return r;
       }
     }
-    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    importLocationCache[source] = void 0;
+    return void 0;
+  }
+  function getImportLocation(fileMap, source) {
+    const found = tryGetImportLocation(fileMap, source);
+    if (!found) {
+      throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    }
+    return found;
   }
   function getTraceLocation(traceMap, source) {
     for (const [path, reg] of traceMap) {
@@ -91901,10 +92012,12 @@ ${lanes.join("\n")}
   function accessPrivateIdentifier(env, name) {
     return walkUpLexicalEnvironments(env, (env2) => getPrivateIdentifier(env2.privateEnv, name));
   }
+  var importLocationCache;
   var init_utilities3 = __esm({
     "src/compiler/transformers/utilities.ts"() {
       "use strict";
       init_ts2();
+      importLocationCache = {};
     }
   });
 
@@ -186969,6 +187082,7 @@ ${e.message}`;
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetJSDocSatisfiesTypeNode: () => tryGetJSDocSatisfiesTypeNode,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
@@ -189342,6 +189456,7 @@ ${e.message}`;
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetJSDocSatisfiesTypeNode: () => tryGetJSDocSatisfiesTypeNode,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
diff --git a/lib/typescript.d.ts b/lib/typescript.d.ts
index ac0f972..1c8c593 100644
--- a/lib/typescript.d.ts
+++ b/lib/typescript.d.ts
@@ -5863,6 +5863,10 @@ declare namespace ts {
      * @param context A lexical environment context for the visitor.
      */
     function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    function tryGetImportLocation(fileMap: [
+        string,
+        RegExp
+    ][], source: string): string | undefined;
     function getImportLocation(fileMap: [
         string,
         RegExp
diff --git a/lib/typescript.js b/lib/typescript.js
index 63dcf00..b5d84b3 100644
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -44995,7 +44995,8 @@ ${lanes.join("\n")}
         for (const key of getOwnKeys(exports)) {
           if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
             const subTarget = exports[key];
-            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+            const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
             if (result) {
               return result;
             }
@@ -45067,7 +45068,7 @@ ${lanes.join("\n")}
     if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
       return void 0;
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
     const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
     return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
     function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -45945,52 +45946,52 @@ ${lanes.join("\n")}
       }
       return out;
     }
-    function collectRelevantSymbolsLoop(target, lastNoInherit, lastSeen) {
+    function collectRelevantSymbolsLoop(originalTarget, lastNoInherit, lastSeen) {
       const seen = new Set(lastSeen);
       const noInherit = new Set(lastNoInherit);
       const relevant = /* @__PURE__ */ new Set();
-      let queue = [target];
+      let queue = [originalTarget];
       while (queue.length > 0) {
-        const target2 = queue.shift();
-        if (target2.symbol) {
-          collectExcludedInheritance(target2.symbol);
-        }
-        if (target2.aliasSymbol) {
-          collectExcludedInheritance(target2.aliasSymbol);
-        }
-        if (target2.symbol && shouldInherit(target2.symbol)) {
-          relevant.add(target2.symbol);
-          if (inheritanceSymbolCache.has(target2.symbol)) {
-            inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
-          } else if (target2.symbol.declarations) {
-            target2.symbol.declarations.forEach((declaration) => {
+        const target = queue.shift();
+        if (target.symbol) {
+          collectExcludedInheritance(target.symbol);
+        }
+        if (target.aliasSymbol) {
+          collectExcludedInheritance(target.aliasSymbol);
+        }
+        if (target.symbol && shouldInherit(target.symbol)) {
+          relevant.add(target.symbol);
+          if (inheritanceSymbolCache.has(target.symbol)) {
+            inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
+          } else if (target.symbol.declarations) {
+            target.symbol.declarations.forEach((declaration) => {
               if ((isInterfaceDeclaration(declaration) || isClassDeclaration(declaration)) && declaration.heritageClauses) {
-                tryCacheTsPlusInheritance(target2.symbol, declaration.heritageClauses);
-                if (inheritanceSymbolCache.has(target2.symbol)) {
-                  inheritanceSymbolCache.get(target2.symbol).forEach(addInheritedSymbol);
+                tryCacheTsPlusInheritance(target.symbol, declaration.heritageClauses);
+                if (inheritanceSymbolCache.has(target.symbol)) {
+                  inheritanceSymbolCache.get(target.symbol).forEach(addInheritedSymbol);
                 }
               }
             });
           }
         }
-        if (target2.aliasSymbol && shouldInherit(target2.aliasSymbol)) {
-          relevant.add(target2.aliasSymbol);
-          if (inheritanceSymbolCache.has(target2.aliasSymbol)) {
-            inheritanceSymbolCache.get(target2.aliasSymbol).forEach(addInheritedSymbol);
+        if (target.aliasSymbol && shouldInherit(target.aliasSymbol)) {
+          relevant.add(target.aliasSymbol);
+          if (inheritanceSymbolCache.has(target.aliasSymbol)) {
+            inheritanceSymbolCache.get(target.aliasSymbol).forEach(addInheritedSymbol);
           }
-          if (target2.flags & 1048576 /* Union */) {
-            collectUnionType(target2);
+          if (target.flags & 1048576 /* Union */) {
+            collectUnionType(target);
           }
-          if (target2.flags & 2097152 /* Intersection */) {
-            collectIntersectionType(target2);
+          if (target.flags & 2097152 /* Intersection */) {
+            collectIntersectionType(target);
           }
         }
-        if (!target2.symbol && !target2.aliasSymbol) {
-          if (target2.flags & 1048576 /* Union */) {
-            collectUnionType(target2);
+        if (!target.symbol && !target.aliasSymbol) {
+          if (target.flags & 1048576 /* Union */) {
+            collectUnionType(target);
           }
-          if (target2.flags & 2097152 /* Intersection */) {
-            collectIntersectionType(target2);
+          if (target.flags & 2097152 /* Intersection */) {
+            collectIntersectionType(target);
           }
         }
       }
@@ -46098,15 +46099,37 @@ ${lanes.join("\n")}
       }
       return returnArray;
     }
+    function getAllTypeTags(targetType) {
+      var _a2, _b, _c;
+      return (_c = (_b = (_a2 = targetType.symbol) == null ? void 0 : _a2.declarations) == null ? void 0 : _b.flatMap(collectTsPlusTypeTags)) != null ? _c : [];
+    }
+    function isInstanceType(type) {
+      if (!type.symbol) {
+        return true;
+      }
+      if (!(type.symbol.flags & 32 /* Class */)) {
+        return true;
+      }
+      const declaredType = getDeclaredTypeOfClassOrInterface(type.symbol);
+      if (!declaredType.symbol) {
+        return true;
+      }
+      return getTypeOfSymbol(declaredType.symbol) !== type;
+    }
     function getExtensions(selfNode) {
       var _a2, _b;
       const targetType = getTypeOfNode(selfNode);
+      const isInstance = isInstanceType(targetType);
       const symbols = collectRelevantSymbols(targetType);
       const copy = /* @__PURE__ */ new Map();
       const copyFluent = /* @__PURE__ */ new Map();
+      const typeTags = getAllTypeTags(targetType);
       symbols.forEach((target) => {
-        if (typeSymbolCache.has(target) && !isCompanionReference(selfNode)) {
+        if (typeSymbolCache.has(target)) {
           typeSymbolCache.get(target).forEach((typeSymbol) => {
+            if (!isInstance && typeTags.includes(typeSymbol)) {
+              return;
+            }
             const _static = staticCache.get(typeSymbol);
             if (_static) {
               _static.forEach((v, k) => {
@@ -46215,17 +46238,22 @@ ${lanes.join("\n")}
     }
     function unionIfLazy(_paramType) {
       const isLazy = isLazyParameterByType(_paramType);
-      const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : _paramType;
+      const paramType = isLazy ? getUnionType([_paramType, _paramType.resolvedTypeArguments[0]], 0 /* None */) : isForceLazyParameterByType(_paramType) ? _paramType.resolvedTypeArguments[0] : _paramType;
       return paramType;
     }
     function getFluentExtension(targetType, name) {
       var _a2, _b;
+      const isInstance = isInstanceType(targetType);
+      const typeTags = getAllTypeTags(targetType);
       const symbols = collectRelevantSymbols(targetType);
       const candidates = /* @__PURE__ */ new Set();
       for (const target of symbols) {
         if (typeSymbolCache.has(target)) {
           const x = typeSymbolCache.get(target).flatMap(
             (tag) => {
+              if (!isInstance && typeTags.includes(tag)) {
+                return [];
+              }
               if (fluentCache.has(tag)) {
                 const cache = fluentCache.get(tag);
                 if (cache == null ? void 0 : cache.has(name)) {
@@ -46262,10 +46290,15 @@ ${lanes.join("\n")}
     function getGetterExtension(targetType, name) {
       var _a2;
       const symbols = collectRelevantSymbols(targetType);
+      const isInstance = isInstanceType(targetType);
+      const typeTags = getAllTypeTags(targetType);
       for (const target of symbols) {
         if (typeSymbolCache.has(target)) {
           const x = typeSymbolCache.get(target).flatMap(
             (tag) => {
+              if (!isInstance && typeTags.includes(tag)) {
+                return [];
+              }
               if (getterCache.has(tag)) {
                 const cache = getterCache.get(tag);
                 if (cache == null ? void 0 : cache.has(name)) {
@@ -50855,17 +50888,17 @@ ${lanes.join("\n")}
           const typeId = type2.id;
           const symbol = type2.symbol;
           if (symbol) {
-            const isInstanceType = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
+            const isInstanceType2 = isClassInstanceSide(type2) ? 788968 /* Type */ : 111551 /* Value */;
             if (isJSConstructor(symbol.valueDeclaration)) {
-              return symbolToTypeNode(symbol, context, isInstanceType);
+              return symbolToTypeNode(symbol, context, isInstanceType2);
             } else if (symbol.flags & 32 /* Class */ && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & 2048 /* WriteClassExpressionAsTypeLiteral */ && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(
               symbol,
               context.enclosingDeclaration,
-              isInstanceType,
+              isInstanceType2,
               /*computeAliases*/
               false
             ).accessibility !== 0 /* Accessible */)) || symbol.flags & (384 /* Enum */ | 512 /* ValueModule */) || shouldWriteTypeOfFunctionSymbol()) {
-              return symbolToTypeNode(symbol, context, isInstanceType);
+              return symbolToTypeNode(symbol, context, isInstanceType2);
             } else if ((_a3 = context.visitedTypes) == null ? void 0 : _a3.has(typeId)) {
               const typeAlias = getTypeAliasForTypeLiteral(type2);
               if (typeAlias) {
@@ -51716,6 +51749,16 @@ ${lanes.join("\n")}
         }
         return top;
       }
+      function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+        let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+        if (specifier && specifier.indexOf("/node_modules/") > 0) {
+          const r = tryGetImportLocation(fileMap.map, specifier);
+          if (r) {
+            specifier = r;
+          }
+        }
+        return specifier;
+      }
       function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
         var _a2;
         let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -51790,7 +51833,7 @@ ${lanes.join("\n")}
           let assertion;
           if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
             if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-              specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+              specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
               assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
                 factory.createAssertEntry(
                   factory.createStringLiteral("resolution-mode"),
@@ -51801,7 +51844,7 @@ ${lanes.join("\n")}
             }
           }
           if (!specifier) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
           }
           if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
             const oldSpecifier = specifier;
@@ -67723,11 +67766,19 @@ ${lanes.join("\n")}
             if (type) {
               const name = node.name;
               const symbol2 = type.symbol || type.aliasSymbol;
-              if (symbol2 && typeSymbolCache.has(symbol2)) {
+              if (symbol2 && (typeSymbolCache.has(symbol2) || companionSymbolCache.has(symbol2))) {
                 const fluentExtenion = getFluentExtension(type, name.escapedText);
                 if (fluentExtenion) {
                   return fluentExtenion;
                 }
+                const staticExtension = getStaticExtension(type, name.escapedText);
+                if (staticExtension) {
+                  return staticExtension.type;
+                }
+                const staticCompanionExtension = getStaticCompanionExtension(type, name.escapedText);
+                if (staticCompanionExtension) {
+                  return staticCompanionExtension.type;
+                }
               }
               let prop;
               if (isPrivateIdentifier(name)) {
@@ -71939,7 +71990,6 @@ ${lanes.join("\n")}
             nodeLinks2.tsPlusResolvedType = companionExt.type;
             return companionExt.type;
           }
-          return;
         }
         const fluentExtType = getFluentExtension(leftType, right.escapedText.toString());
         if (fluentExtType && isCallExpression(node.parent) && node.parent.expression === node) {
@@ -72836,6 +72886,15 @@ ${lanes.join("\n")}
       }
       return false;
     }
+    function isForceLazyParameterByType(type) {
+      if (type.symbol && type.symbol.declarations && type.symbol.declarations.length > 0) {
+        const tag = collectTsPlusTypeTags(type.symbol.declarations[0])[0];
+        if (tag === "tsplus/ForceLazyArgument") {
+          return true;
+        }
+      }
+      return false;
+    }
     function getMutableArrayOrTupleType(type) {
       return type.flags & 1048576 /* Union */ ? mapType(type, getMutableArrayOrTupleType) : type.flags & 1 /* Any */ || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type : isTupleType(type) ? createTupleType(
         getTypeArguments(type),
@@ -73041,7 +73100,7 @@ ${lanes.join("\n")}
         const thisArgumentType = getThisArgumentType(thisArgumentNode);
         const originalParamType = thisType;
         let paramType = originalParamType;
-        if (isLazyParameterByType(originalParamType) && thisArgumentNode) {
+        if ((isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) && thisArgumentNode) {
           const contextFreeArgType = thisArgumentType;
           if (isTypeIdenticalTo(contextFreeArgType, anyType) || isTypeIdenticalTo(contextFreeArgType, neverType)) {
             return [createDiagnosticForNode(
@@ -73079,7 +73138,7 @@ ${lanes.join("\n")}
             checkMode
           );
           let paramType = originalParamType;
-          if (isLazyParameterByType(originalParamType)) {
+          if (isLazyParameterByType(originalParamType) || isForceLazyParameterByType(originalParamType)) {
             if ((isTypeIdenticalTo(argType, anyType) || isTypeIdenticalTo(argType, neverType)) && !(checkMode & 8 /* SkipGenericFunctions */)) {
               return [createDiagnosticForNode(
                 arg,
@@ -86490,7 +86549,46 @@ ${lanes.join("\n")}
       const heritageExtensions = inheritanceSymbolCache.get(typeSymbol);
       forEach(heritage, (clause) => {
         forEach(clause.types, (node) => {
+          var _a2;
           const type = getTypeOfNode(node);
+          if (isIdentifier(node.expression)) {
+            const links = getNodeLinks(node.expression);
+            const declaration = (_a2 = links.resolvedSymbol) == null ? void 0 : _a2.valueDeclaration;
+            const vType = declaration && checker.getTypeAtLocation(declaration);
+            if (vType) {
+              if (vType.symbol) {
+                heritageExtensions.add(vType.symbol);
+              }
+              if (vType.flags & 2097152 /* Intersection */) {
+                forEach(vType.types, (type2) => {
+                  if (type2.symbol) {
+                    heritageExtensions.add(type2.symbol);
+                  }
+                  if (type2.aliasSymbol) {
+                    heritageExtensions.add(type2.aliasSymbol);
+                  }
+                });
+              }
+            }
+          } else if (isCallExpression(node.expression)) {
+            const resolvedSignature = getResolvedSignature(node.expression);
+            const returnType = resolvedSignature.resolvedReturnType;
+            if (returnType) {
+              if (returnType.symbol) {
+                heritageExtensions.add(returnType.symbol);
+              }
+              if (returnType.flags & 2097152 /* Intersection */) {
+                forEach(returnType.types, (type2) => {
+                  if (type2.symbol) {
+                    heritageExtensions.add(type2.symbol);
+                  }
+                  if (type2.aliasSymbol) {
+                    heritageExtensions.add(type2.aliasSymbol);
+                  }
+                });
+              }
+            }
+          }
           if (type.symbol) {
             heritageExtensions.add(type.symbol);
           }
@@ -91455,13 +91553,26 @@ ${lanes.join("\n")}
     node = getOriginalNode(node);
     return node ? getNodeId(node) : 0;
   }
-  function getImportLocation(fileMap, source) {
+  function tryGetImportLocation(fileMap, source) {
+    if (source in importLocationCache) {
+      return importLocationCache[source];
+    }
     for (const [path, reg] of fileMap) {
       if (source.match(reg)) {
-        return source.replace(reg, path);
+        const r = source.replace(reg, path);
+        importLocationCache[source] = r;
+        return r;
       }
     }
-    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    importLocationCache[source] = void 0;
+    return void 0;
+  }
+  function getImportLocation(fileMap, source) {
+    const found = tryGetImportLocation(fileMap, source);
+    if (!found) {
+      throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    }
+    return found;
   }
   function getTraceLocation(traceMap, source) {
     for (const [path, reg] of traceMap) {
@@ -91901,10 +92012,12 @@ ${lanes.join("\n")}
   function accessPrivateIdentifier(env, name) {
     return walkUpLexicalEnvironments(env, (env2) => getPrivateIdentifier(env2.privateEnv, name));
   }
+  var importLocationCache;
   var init_utilities3 = __esm({
     "src/compiler/transformers/utilities.ts"() {
       "use strict";
       init_ts2();
+      importLocationCache = {};
     }
   });
 
@@ -176154,6 +176267,7 @@ ${options.prefix}` : "\n" : options.prefix
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetJSDocSatisfiesTypeNode: () => tryGetJSDocSatisfiesTypeNode,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
